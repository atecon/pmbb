<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="pmbb" minver="2022b">
<author email="giuseppe.vittucci@gmail.com">Giuseppe Vittucci and Artur Tarassow</author>
<version>1.8</version>
<date>2023-04-27</date>
<description>Moving Blocks Bootstrap (MBB) for linear panels</description>
<tags>C10</tags>
<help filename="pmbb_help.md">
# Introduction

The function implements the panel Moving Blocks Bootstrap (MBB) suggested and
analysed by Gonçalves, S. (2011, *The moving blocks bootstrap for panel linear
regression models with individual fixed effects*, Econometric Theory).

The panel MBB is different from the standard MBB of Kunsch (1989, *The 
jackknife and the Bootstrap for General Stationary Observations*, The Annals of 
Statistics) and Liu and Singh (1992, *Moving Blocks Jackknife and Bootstrap 
Capture Weak Dependence*. In: R. Lepage and L. Billard, Eds., Exploring the 
Limits of Bootstrap, John Wiley, New York), because what is drawn in the 
resampling is the vector containing the *n* individual observations at each 
point in time. The panel MBB is robust to serial correlation (like the standard 
MBB), but also to arbitrary forms of cross sectional dependence.

The simulations carried out in the paper show that the panel MBB performs well
even when the degree of serial and cross sectional correlation is large, 
provided that the block size is appropriately chosen.
In the simulations, Gonçalves adopts a data-driven approach, with a block size
equal on average to:
- 4.4 when T = 25;
- 7.9 when T = 50;
- 12.2 when T = 100.

Please report bugs or comments on github (https://github.com/atecon/pmbb) or
write to giuseppe.vittucci@gmail.com.

# Public function

```
pmbb(const series y, const list X, int blocksize[1::4], int nboot[100::1000],
     int pseed[0::0])
```

The function computes and shows also the symmetric bootstrap percentile-t
confidence intervals of the coefficients at the 1%, 5% and 10% significance
level. The bootstrap percentile-t confidence intervals are calculated as:
beta_hat +/- q_alpha x se_beta
where:

- beta_hat is the FE estimate of the coefficient;
- se_beta is the sqrt of the bootstrap variance estimator based on B bootstrap
replications;
- q_alpha is the alpha x 100 percentile of the absolute value of the 
Studentized bootstrap statistic.

The bootstrap t-statistic is Studentized using the multivariate analogue of the
Götze and Kunsch (1996, Second-Order Correctness of the Blockwise Bootstrap for
Stationary Observations, The Annals of Statistics) variance estimator, adapted
to panel models by Gonçalves (2011).

Please note that the function works only with perfectly balanced panels (no
missing observation).


## Parameters

- `y`:           series, dependent variable
- `X`:           list, regressors (without the constant which is added by 
default)
- `blocksize`:   int, Length of blocksize (default = 4)
- `nboot`:       int, Number of bootstrap replications (default = 1000)
- `pseed`        int, Seed of pseudo-random number generator (default = 0 
(none))

## Returns

The function returns a bundle with:

- `blocksize`: int, Choosen block length
- `coeff`: matrix, Column vector of length `k` referring to the point estimates 
of the coefficients (intercept coefficient not shown)
- `coeffs`: matrix, `nboot` x `k` matrix holding the individual coefficient 
estimates for each bootstrap replication
- `confidence_levels`: matrix, Row column holding the confidence levels
- `N`: int, Number of cross-sectional units
- `T`: int, Length of time-series of the panel dataset
- `nT`: int, Total number of observations
- `nboot`: int, Number of bootstrap iterations set
- `parnames`: strings, Array of regressor names (without intercept)
- `stderr`: matrix, Column vector of length `k` referring to the standard 
errors for each coefficient (not shown for intercept coefficient)
- `tstats`: matrix, `nboot` x `k` matrix holding the Studentized test 
statistics for each bootstrap replication
- `q90`: matrix, Holds the lower and upper bounds (in columns) for each 
regressor (in rows) for the 90 pct. confidence interval of the coefficient 
estimates.
- `q95`: matrix, See description for `q90`.
- `q99`: matrix, See description for `q90`


# Changelog

* **v1.8 (April 2023)**
  * Rewrite help text (using Markdown now) and add references
  * Internal refactoring and optimization

* **v1.7 (March 2018)**
  * re-write of the code leads to speed-up by factor 8
  * pre-allocation of some big matrices
  * re-write of some loop functions leads to more efficient computations incl.
    vectorization
</help>
<gretl-function name="pmbb" type="bundle">
 <params count="5">
  <param name="y" type="series" const="true"/>
  <param name="X" type="list" const="true"/>
  <param name="blocksize" type="int" min="1" max="50" default="4"/>
  <param name="nboot" type="int" min="100" max="50000" default="1000"/>
  <param name="pseed" type="int" min="0" default="0"/>
 </params>
<code>/* Main function. */

if pseed
  set seed pseed
endif

bundle self = _(blocksize, nboot)
scalar self.N = max($unit)
scalar self.T = $pd
scalar nblocks = ceil(self.T / self.blocksize)
matrix yX = {y} ~ {X}
matrix self.confidence_levels = {0.99, 0.95, 0.90}

panel y 0 X --quiet

scalar self.nT = $T
matrix self.coeff = $coeff[2:]      # disregard &quot;const&quot;
self.parnames = $model.parnames[2:]
rnameset(self.coeff, self.parnames)
scalar ncoeff = $ncoeff
scalar ncoeff_wo_const = ncoeff - 1

scalar r = rows(yX) / self.T * cols(yX)
scalar r = self.N * ncoeff
matrix minit = seq(1, r, ncoeff)
matrix MW = zeros(self.T, r)
matrix self.coeffs = zeros(self.nboot, ncoeff_wo_const)
matrix self.tstats = zeros(self.nboot, ncoeff_wo_const)

# From long to wide format
loop i=1..self.N
  scalar last = minit[i] + ncoeff - 1
  scalar init_yX = 1+(i-1)*self.T
  MW[,minit[i]:last] = yX[init_yX:i*self.T,]
endloop

loop q=1..self.nboot
  matrix MB = zeros(self.nT, ncoeff)
  matrix randblock = round((self.T - self.blocksize) * muniform(nblocks, 1))
  matrix minit = seq(1, self.nT+1, self.T)
  matrix MBW = {}
  matrix uhat = {}
  matrix S1 = {}

  # TODO: Initializing the right dimension of MBW may save time
  # Resampling
  loop i=1..nblocks
    scalar tmp = randblock[i]
    MBW = MBW | MW[tmp+1:tmp+self.blocksize,]
  endloop

  MBW = MBW[1:self.T,]
  MBW = MBW .- meanc(MBW)

  loop i=1..self.N
    scalar endrow = minit[i] + self.T - 1
    scalar initcol = 1 + (i-1) * ncoeff
    scalar endcol = i * ncoeff
    MB[minit[i]:endrow,] = MBW[,initcol:endcol]
  endloop

  matrix my = MB[,1]
  matrix mx = MB[,-1]

  catch bhat = mols(my, mx, &amp;uhat)

  if $error
    # in case of an error, rely on the initial point estimate
    self.coeffs[q,] = self.coeff'
    matrix uhat =  MB[,1] - sumr(MB[,2:ncoeff] .* self.coeff')
  else
    self.coeffs[q,] = transp(bhat)
  endif

  # Scores
  matrix S = MB[,2:ncoeff] .* uhat

  loop o=1..ncoeff_wo_const
    matrix s = sumr(mshape(S[,o], self.T, self.N)) / self.N
    matrix s1 = zeros(nblocks, 1)

    loop m=1..self.T
      scalar j = int((m-0.5) / self.blocksize) + 1
      s1[j] += s[m]
    endloop

    S1 ~= s1 / sqrt(self.blocksize)
  endloop

  B1 = (S1'S1) / nblocks
  matrix A1 = self.nT * invpd(MB[,2:ncoeff]' MB[,2:ncoeff])
  matrix mat = qform(A1, B1)
  matrix C = transp(sqrt(diag(mat)))

  # Absolute value of the Studentized bootstrap statistic
  self.tstats[q,] = abs(sqrt(self.T) * ( (self.coeffs[q,] - self.coeff') ./ C) )
endloop

matrix self.stderr  = sqrt(self.T) * sdc(self.coeffs)'
rnameset(self.stderr, self.parnames)

confidence_intervals(&amp;self, self.confidence_levels)

print_header (self, nblocks)
print_results(self)

return self
</code>
</gretl-function>
<gretl-function name="confidence_intervals" type="void" private="1">
 <params count="2">
  <param name="self" type="bundleref"/>
  <param name="confidence_levels" type="matrix" const="true"/>
 </params>
<code>/* Compute confidence intervals of coefficients. Add matrices to self.
Each matrix has the same number of rows as `coeff`, and 2 columns: the lower bound and the upper bound, respectively. The name of the matrices have the format &quot;qXX&quot;, where &quot;XX&quot; is the confidence level multiplied by 100 (e.g., &quot;q95&quot; for a 95% confidence level).

Args:
self (bundle): Bundle (in pointer form) holding various objects.
confidence_levels (matrix): Vector of confidence levels (in the range [0,1]) for which to compute intervals.

Note:
The intervals are computed using the formula point_estimate +- t_stat * stddev, where t_stat is the (1-confidence_level/2)-quantile of the bootstrap t-statistics.
*/

loop i=1..nelem(confidence_levels)
  matrix q = quantile(self.tstats, confidence_levels[i])'
  matrix lower = self.coeff - q .* self.stderr
  matrix upper = self.coeff + q .* self.stderr

  string vname = intval_matrix_name(confidence_levels[i])
  matrix self.@vname =  lower ~ upper
  cnameset(self.@vname, defarray(&quot;Lower&quot;, &quot;Upper&quot;))
  rnameset(self.@vname, self.parnames)
endloop
</code>
</gretl-function>
<gretl-function name="intval_matrix_name" type="string" private="1">
 <params count="1">
  <param name="cilevel" type="scalar" const="true"/>
 </params>
<code>/* Construct a string for a confidence interval level.

Args:
cilevel (scalar): the confidence interval level, a number between 0 and 1.

Returns:
A string of the form &quot;qXX&quot;, where &quot;XX&quot; is the integer representation of 100 times the confidence interval level. This string can be used as a key to store and retrieve the corresponding confidence intervals in a bundle.
*/
return sprintf(&quot;q%d&quot;, 100*cilevel)
</code>
</gretl-function>
<gretl-function name="print_header" type="void" private="1">
 <params count="2">
  <param name="self" type="bundle" const="true"/>
  <param name="nblocks" type="scalar" const="true"/>
 </params>
<code>printf &quot;\nPanel Moving Blocks Bootstrap (MBB) for linear regression models with fixed effects\n&quot;
printf &quot;Bootstrap standard errors and symmetric bootstrap percentile-t confidence intervals\n&quot;
printf &quot;\n  No. of bootstrap replications: %d\n&quot;, self.nboot
printf &quot;  Average block size: %g\n&quot;, (self.T / nblocks)
</code>
</gretl-function>
<gretl-function name="print_results" type="void" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Print coefficient estimates and confidence intervals. */

matrix mat = merge_coeff_stderr(self.coeff, self.stderr)
printf &quot;\nPoint estimates and bootstrap standard errors:\n&quot;
printf &quot;\n%16.5f\n&quot;, mat

matrix mat = merge_intervals(self)
print &quot;Bootstrap confidence intervals for different confidence levels:&quot;
printf &quot;\n%16.5f\n&quot;, mat
</code>
</gretl-function>
<gretl-function name="append_suffix" type="strings" private="1">
 <params count="2">
  <param name="str" type="strings" const="true"/>
  <param name="suffix" type="string" const="true"/>
 </params>
<code>/* Append a suffix to each string in an array of strings.

Args:
str (strings): an array of strings.
suffix (string): the suffix to append to each string in the array.

Returns:
An array of strings where each string has the suffix appended at the end.
*/
strings ret = array(nelem(str))

loop foreach i str
  ret[i] = sprintf(&quot;%s%s&quot;, str[i], suffix)
endloop

return ret
</code>
</gretl-function>
<gretl-function name="merge_intervals" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Merge horizontally confidence intervals for different levels.

Args:
self (bundle): a bundle containing matrices of confidence intervals for different levels. The keys of the matrices must have the format &quot;qXX&quot;, where &quot;XX&quot; is the confidence level multiplied by 100.

Returns:
A matrix where the columns correspond to the different confidence interval levels and the rows correspond to the same coefficients for each level of confidence. The column labels are constructed by concatenating the original column names with the suffix &quot;(qXX)&quot;, where &quot;XX&quot; is the integer representation of the corresponding confidence level multiplied by 100. */

matrix ci = {}
strings clabels = array(0)

loop i=1..nelem(self.confidence_levels)
  string vname = intval_matrix_name(self.confidence_levels[i])
  ci ~= self.@vname

  clabels += append_suffix(cnameget(self.@vname), sprintf(&quot;(q%d)&quot;, 100*self.confidence_levels[i]))
endloop
cnameset(ci, clabels)

return ci
</code>
</gretl-function>
<gretl-function name="merge_coeff_stderr" type="matrix" private="1">
 <params count="2">
  <param name="coeff" type="matrix" const="true"/>
  <param name="stderr" type="matrix" const="true"/>
 </params>
<code>matrix cs = coeff ~ stderr
cnameset(cs, defarray(&quot;coefficient&quot;, &quot;std. error&quot;))

return cs
</code>
</gretl-function>
<sample-script>
set verbose off
include pmbb.gfn
open greene14_1.gdt

logs C Q PF LF
list X = l_Q l_PF l_LF

bundle bb = pmbb(l_C, X, 2)
print bb
</sample-script>
</gretl-function-package>
</gretl-functions>
