function bundle pmbb (const series y "dependent variable",
                      const list X "regressors (w/o constant)",
                      int blocksize[1:50:4] "Length block size",
                      int nboot[100:50000:1000] "#bootstrap replications",
                      int pseed[0::0] "seed (0 = none)")
    /* Main function. */

    if pseed
        set seed pseed
    endif

    scalar n = max($unit)
    scalar T = $pd
    scalar k = ceil(T/blocksize)
    matrix yX = {y} ~ {X}
    string parnames = strsub(varname(X),","," ")

    panel y 0 X --quiet

    scalar nT = $T
    matrix coeff = transp($coeff[2:])
    scalar ncoeff = $ncoeff
    scalar ncoeff_wo_const = ncoeff - 1

    matrix bb = zeros(nboot, ncoeff_wo_const)
    matrix tt = zeros(nboot, ncoeff_wo_const)
    scalar r = rows(yX) / T * cols(yX)
    matrix MW = zeros(T, r)
    scalar r = n * ncoeff + 1
    matrix minit = seq(1, r, ncoeff)

    loop i = 1..n
        scalar last = minit[i] + ncoeff - 1
        MW[,minit[i]:last] = yX[1+(i-1)*T:i*T,]
    endloop

    loop q = 1..nboot
        matrix MB = zeros(nT, ncoeff)
        matrix value = round((T - blocksize) * muniform(k, 1))
        matrix minit = seq(1, nT+1, T)
        matrix MBW = {}
        matrix uhat = {}
        matrix S1 = {}

        # TODO: Initializing the rigth dimension of MBW would save time
        loop i = 1..k
            scalar tmp = value[i]
            MBW = MBW | MW[tmp+1:tmp+blocksize,]
        endloop

        MBW = MBW[1:T,]
        MBW = MBW .- meanc(MBW)

        loop i = 1..n
            scalar endrow = minit[i] + T - 1
            scalar initcol = 1 + (i-1) * ncoeff
            scalar endcol = i * ncoeff
            MB[minit[i]:endrow,] = MBW[,initcol:endcol]
        endloop

        matrix my = MB[,1]
        matrix mx = MB[,-1]

        catch coef = mols(my, mx, &uhat)
        if $error
            bb[q,] = coeff
            matrix uhat =  MB[,1] - sumr(MB[,2:ncoeff] .* coeff)
        else
            bb[q,] = transp(coef)
        endif

        matrix S = MB[,2:ncoeff] .* uhat

        loop o = 1..ncoeff_wo_const
            matrix s = sumr(mshape(S[,o], T, n)) / n
            matrix s1 = zeros(k, 1)

            loop m = 1..T
                scalar j = int((m-0.5) / blocksize) + 1
                s1[j] += s[m]
            endloop

            s1 = s1 / sqrt(blocksize)
            S1 ~= s1
        endloop

        B1 = (S1'S1)/k
        matrix A1 = nT * invpd(MB[,2:ncoeff]' MB[,2:ncoeff])
        matrix mat = qform(A1, B1)
        matrix C = transp(sqrt(diag(mat)))

        tt[q,] = abs(sqrt(T) * ( (bb[q,]-coeff) ./ C) )
    endloop

    matrix se  = sqrt(T) * sdc(bb)

    matrix ci = { }
    matrix cilevels = {0.99, 0.95, 0.90}
    loop i=1..nelem(cilevels)
        matrix q = quantile(tt, cilevels[i])
        matrix c1 = coeff - q .* se
        matrix c2 = coeff + q .* se
        matrix ci |= c1 | c2
    endloop

    printf "\nPanel Moving Blocks Bootstrap (MBB) for linear regression models with fixed effects\n"
    printf "Bootstrap standard errors and symmetric bootstrap percentile-t confidence intervals\n"
    printf "\n  No. of bootstrap replications: %d\n", nboot
    printf "  Average block size: %g\n", T/k
    printf "  \t\tcoefficient\ts.e.\t\t\t1%% CI\t\t\t5%% CI\t\t\t10%% CI\n"
    printf "  ---------------------------------------------------------------------------------------------------------------------\n"
    loop j = 1..ncoeff_wo_const
        parname = strsplit(parnames,$j)
        if strlen(parname) > 5
            printf "  %s\t", parname
        else
            printf "  %s\t\t", parname
        endif
        printf "%8.5f\t%8.5f\t%10.4f %10.4f   %10.4f %10.4f   %10.4f %10.4f\n",
          coeff[j],se[j],ci[1,j],ci[2,j],ci[3,j],ci[4,j],ci[5,j],ci[6,j]
    endloop
    printf "\n"

    bundle output
    output["beta"] = bb
    output["tstat"] = tt
    return output
end function
